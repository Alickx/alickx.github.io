---
title: 掘金小册-Java 并发编程-读后总结（一）
date: 2022-08-27 15:42:18
permalink: /pages/1b95c2/
---

阅读掘金小册 Java 并发编程后的读后总结。


<!-- more -->

## 1. 回顾

1. 经典的i++问题
2. 程序和Cpu之间的协作关系
3. Cpu的几大模块
4. 寄存器和程序之间的关系
5. 临界区
6. 信号量
7. 管程和其三大模型



## 2. 学习

### 1. 经典的i++问题

在开章作者给出了一段代码，通过CountDownLatch模拟并发线程执行加操作。下面贴上这段代码。

```java
public class ThreadDemo {

    private static int j = 0;


    static class IncrTask implements Runnable {
        CountDownLatch start;
        CountDownLatch end;

        public IncrTask(CountDownLatch start, CountDownLatch end) {
            this.start = start;
            this.end = end;
        }

        @Override
        public void run() {
            try {
                start.await();
                for (int i = 0; i < 100; i++) {
                    j++;
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                end.countDown();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        CountDownLatch start = new CountDownLatch(1);
        CountDownLatch end = new CountDownLatch(100);
        for (int i = 0; i < 100; i++) {
            Thread t = new Thread(new IncrTask(start, end));
            t.start();
        }
        start.countDown();
        end.await();
        System.out.println("result is :" + j);
    }
}
```

在Idea上执行一下这段代码试试看。有概率获得数值会低于10000。

![image-20220827143709293](https://img.llwstu.com/img/202208271437497.png)



这里之所以低于10000是因为这里i++操作包含了三个操作，一个是读取数值，第二个是进行增加，第三个是将增加后的数值设置回原先的内存地址当中。其中有可能在你读取数值后，其他线程对这个变量进行的增加并比第一个线程**先一步设置回原先的内存地址当中**。这就会导致，你设置的值是旧值，所以会发生最终结果会少于10000的情况出现。

### 2. 程序与cpu的协作关系

Cpu中存在寄存器，控制器，运算器和时钟。其中寄存器是我们最需要关心的地方，因为其主要存储了从内存中加载的数据。寄存器的读写速度比内存高了不知道多少个级别，所以需要L1,L2,L3缓存来存储这些数据。

其实我们在业务中运用到的二级缓存，三级缓存的思想也是参考计算机硬件设计思想的。

![image.png](https://img.llwstu.com/img/202208271448204.webp)



### 3. Cpu的几大模块

上面就列出了，Cpu主要的模块有寄存器，控制器，时钟，运算器。其中寄存器又分为两大类，分别是`存储内存地址类寄存器`和`存储非内存地址寄存器`。这两大类下面又有这些小类。

![img](https://img.llwstu.com/img/202208271451193.webp)

### 4. 寄存器和程序之间的关系

举刚才的i++的例子，我们`编写好代码`，代码首先会持久化到`硬盘`上，然后运行的时候，我们会编译这段代码，从硬盘中读取该代码的`后缀为java`的文件，这个文件就是纯天然无污染的我们写的代码文件，然后通过`javac`命令编译生成class文件，即`字节码`文件，然后通过JIT编译再将字节码文件编译成`机器码`。

上面所使用到的javac指令还有JIT编译器其实都是属于Java编译器的一个大类。 先将java代码编译成字节码，再将字节码编译成机器码。 Java也属于**半编译半解释**的语言。

![image.png](https://img.llwstu.com/img/202208271504427.webp)



机器码存放的**地址**会被放到一种叫做**程序计数器**的寄存器中，之后**控制器**会到根据程序计数器的地址去读取相关的机器指令，并且将指令读取给**运算器**进行计算。当运行结束之后，**程序计数器的地址就会刷新，让控制器去加载新内存地址的指令给到运算器。**

最后面的刷新和加载新地址，其实也就对应了我们i++操作中，读取地址，进行修改，设置回去。



### 5. 临界区

在操作系统的课程上，我了解到临界区这一个名词。当时背到的解释是访问临界资源的代码就叫临界区。那这个临界资源其实就是指共享资源，当某一时刻同时有多个进程或者线程访问某一临界区的时候，就可能会出现数据安全问题。



### 6. 信号量

在操作系统课程上，我也学习到信号量这一个名词，信号量是线程或进程间通信的一种方式。文章中也说到是一种设计思想，本质可以理解为一个整形的数字，对于这个数字的操作，就有熟悉的PV操作。

sem 即 信号量

P(): sem - 1，如果sem为0则进入等待状态

v(): sem + 1，如果sem为0则同时会唤醒一个等待的P

信号量的操作是具有`原子性`的，原子性指的就是全部操作要不全部成功，要不全部失败，不会出现一些成功，一些失败。这里的实现是依赖于操作系统的底层，即`原语`。

![image.png](https://img.llwstu.com/img/202208271515427.webp)



### 7.管程和其三大模型

> `管程` 可以理解为是基于信号量的基础上做了一层封装，专门用于访问一些共享变量的函数，让其调用方使用起来更加简单和清晰，它的作用是**一次只允许有一个线程访问临界期，如果同时有太多个访问，则将多余的访问挂起**。
>
> **这里需要注意的是，信号量的应用主要是基于操作系统层面中，而管程的提出** **，** **则是用在了语言的场景中，它主要是专门针对语言中的并发场景而设计的，从而简化了一些语言层面的实现逻辑。**
>
> 例如Java内部对于并发模块的实现 wait()、notify()、notifyAll() 这些函数就是采用了管程技术来控制的。

说白了，其实就是在我们使用的高级语言的层面对底层PV操作进行了封装，让我们可以通过简单的函数就可以操作。这就叫管程。

那还有一个叫`协程`的东西呢？ 协程是一个在线程之上，在进程之下的一个东西。当我们有多个请求的时候，我们需要起对应请求数量的线程来处理，线程之间的切换同时也要经过用户态和内核态。可是协程可以通过复用的方式，不需要多个线程，只需要一个线程就可以执行。

下面是廖雪峰官网的解释: [廖雪峰的官方网站 - 协程](https://www.liaoxuefeng.com/wiki/1016959663602400/1017968846697824)

> 最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
>
> 第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。
>
> 因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。

管程的组成：

- 一把锁
- 0或者多个条件变量

**一把锁：** 管程为了保证对于共享资源的访问一次只能有一个元素，所以才引入了锁的机制，没有抢到锁的请求则需要进入到**锁的等待队列，主要是为了确保互斥性。**

**0或者多个条件变量：** 当获取到了锁的请求进入到了临界区模块中之后，有可能还需要做多个条件的判断，如果没有满足其中的某一条条件则需要进入到**条件的等待队列**中。

![img](https://img.llwstu.com/img/202208271526213.webp)



当 Condition 调用了 signal() 函数的时候，会唤醒等待队列中的一个挂起线程，那么就会产生同时有两个线程访问到了临界区的共享资源，一个是当前触发 signal 函数的线程，一个是刚从挂起状态被唤醒的线程，这种情况下该如何处理呢？



业界提出了三种管程的模型，三大模型则分别是`Hansen`,`Hoare`,`Mesa`模型。模拟一个场景，被挂起的线程为A，调用signal的线程为B

```java
Lock::Acquire() //等待锁可用，然后抢占
Lock::Release() //释放锁，唤醒等待队列中的线程
Wait() //释放当前锁，进入睡眠状态，
Signal() //当某个条件满足的时候，就会唤醒等待队列中线程
```



抢到锁的线程想要主动释放锁，那么就需要主动地调用wait()方法。

<img src="https://img.llwstu.com/img/202208271535519.webp" alt="image.png" style="zoom: 67%;" />

1. Hansen ： 让A立即执行，B则处于睡眠状态，在等待A放行之后才继续让B执行。
2. Horare ： 等待B完全执行完毕后，才允许让被唤醒的A继续执行。
3. Mesa : B在执行Signal后不需要担心A的任何事情，B可以继续正常执行，A则会被重新放入到等待队列去参与抢占的行为。



